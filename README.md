# MicroServiceArchitecture

## 마이크로 서비스 아키텍처

### 마이크로 서비스란?

응용 프로그램 도메인의 컨텍스트 내에서 단일 초점 지점이 있는 서비스이다, 서비스는 콘솔, HTTP 기반 API, 이벤트 기반 도는 기타 유형의  프로세스라고 할수 있다.

마이크로 서비스는 그 자체로 완전한 어플리케이션을 구성하지 안흔다, 비지니스를 항목 별로 만들어 구성하게 된다.

### 마이크로서비스의 이해

**마이크로서비스 아키텍처는 여러 마이크로서비스를 결합하여 완벽하게 작동하는 시스템을 만드는 것입니다**

여기서는 구현으로 전자 상거래 에플리케이션의 아키텍처를 Order, Basket, Product API Server를 구성하여 프론트엔드를 통해 시스템과 상호 작용하는 어플리케이션을 구축할예정이다.

각 마이크로서비스는 데이터 스토어를 사용하여 작동하는데 필요한 정보를 유지하며 다른 마이크로서비스가 소유한 데이터 스토어에 연겨하지 않는다.

각 마이크로 서비스의 기능과 코드 베이스를 결합하는 것을 의미하지 않는다, API또는 이벤트를 통해 마이크로서비스가 작동하며 어플리케이션의 결합을 제공한다.

### 마이크로 서비스 장점

* 소수의 개발자가 쉽게 유지관리
  * 한가지 작업에대해서만  집중하기 떄문에 변경의 가능성이 낮다.
  * 단일 책임원칙을 고수하기 유리
  * 자체 데이터 저장소를 소유하며, 다른 서비스가 데이터와 상호 작용하는것을 허용하지 않는다.
* 지속적인 가치를 제공
  * 작은 서비스를 사용하면 서비스에 대한 더 많은 자동화된 테스트를 작성이 가능
  * 모놀리식 코드보다 외부 의존성이 적으며 모방하기 쉽다.
  * 기능별로 프로젝트를 구성하기 떄문에 새로운 기능이 구현될때 해당 프로젝트만 개발하면되고 그로인한 영향을 끼치기 어렵다
* 확장성이 뛰어나고 가용성이 뛰어남
  * 시스템과 사용자의 요구를 충족할 수 있는 능력을 의미

### 마이크로 서비스 단점

* 복잡성
  * 단일 솔루션이아닌 각 기능별로 나누어 독립적인 코드베이스를 가진다.
* 지연시간 증가
  * 다른 서비스와 느슨하게 결합되기를 원한다
    * 이벤트와 메시징을 사용하는 비동기 서비스를 선택 각 서비스들에게 메시지를 전달하게 된다.
  * 서비스간 호출을 수행시 대기시간이 늘어난다,
  * HTTP 또는 gRPC 대기시간 떄문에 하나의 프로세스로 구성된 시스템보다 느리다.
* 코드 리펙토링

### 마이크로서비스 용이한 사용법

모놀리식 아키텍쳐를 새 어플리케이션을 개발시 사용하는것이 좋다 적은 인원 적은 사용자 시 병목현상이 심한 시스템을 도입하긴 힘들다, 그러나 이미 여러개발자와 팀이 잘 구축이되엉 있다면 마이크로 서비스 아키택쳐를 선택하는것도 좋은 선택이 될것이다

## 마이크로 서비스 간의 통신

### 동기식 통신

가장 이반적인 동기 통신의 형태는 HTTP 이다, 각 프로세스가 API 서버로 구성되어 서로간 HTTP 통신을 이용해 응답을 주고받는다, 이방법은 간단하지만 송신 및 수신 의 응답이 시간이 오래 걸리는 경우 성능이 저하될 수 있다.

hTTP는 여러 프로그램간 느슨하게 통신이 이루어지며 데이터가 JSON, XML로 직렬화되어 페이로드 크기가 상당히 커질 때 대기시간이 오래거릴 수있다.

대체 동기 통신 방식으로는 원격 프로시저 호출을 수행하는 gRPC가 존재한다, 이것은 다른서비스에서 메소드를 실행 시키기 때문에 잘 정의된 계약을 가진 모놀리식에서 볼 수 있는 동작과 유사하다, 또한 이점은 데이터 페이로드가 protobuf 형식으 사용하여 바이너리로 직렬화되어 HTTP 보다 효율적이며 빠르다

### 비동기식 통신

요청자가 다운 스트림 서비스로부터 응답을 받을 때까지 차단하지 않고 폴링 혹은 웹훅을 도입하여 요청자가 데이터를 제공할 준비가 될떄마다 다운스트림으로 부터 구독된 메시지를 수신 받을수 있도록한다,

예를 들어 서비스 A는 다른 서비스 B에 요청을한다, 장기 실행 프로세스이므로 마이크로 서비스 B는 URL또는 식별자로 신속하게 응답하므로 마이크로서비스 A 가 프로세스 상태를 확인하기위한 후속요청을 처리할 수있다.

이를 통해 시스템이 보다 반응적으로 작용하여 변경 사항에 보다 효율적이고 효율적으로 대응할 수 있습니다. HTTP 폴링 또는 웹훅은 우리의 통제를 벗어난 제3자 코드가 비즈니스 요구 사항에 활용하는 공개 API가 있을 때마다 잘 작동합니다.

### 게시자 및 구독자 RabbitQ

메시지를 발행하는 서비스가 있을 때 이를 서비스 게시자라고 할 수있는데 다른 서비스에서는 게시자로부터 메시지를 수신하려는 서비스 구독자가 있다. 모든 서비스는 게시자 또는 구독자가 될 수 있다, 메시지 브로커를 이용해 게지사에게 각 구독되어 있는 서비스에게 메시지가 있음을 알리는 서비스이다, 일반적으로 게시자와 구독자를 1:다로 생각한다.

여러 이점을 얻을수 있는데

* 구독자와 개시자는 서로 완전히 분리될 수있다. 서로 알필요가 없다는 말이다, 게시자는 개시만하면되고 구독자는 데이터를 파싱만 잘하면 된다
* 비동기 통신 유형이며 메시지는 백그라운드 스레다, 에서 수신된다, 이를 통해 메시지를 보내고 받을 때 오류가 발생해도 복원이 가능하다
* 

---

# 첫번째 프로잭트 구성

전자 상거래 도메인 구축 예정

## Basket 마이크로 서비스

장바구니 서비스.

REST API 를 준수한 API 를 구축, HTTP 보다 빠른 gRPC , 메시지 또는 큐 기반의 메시지 브로커에게 메시지를 게시할수 있도록 하는 방식으로 서비스끼리 통신을 한다.

장바구니 서비스는 HTTP REST Api 구현

docker build -t basket.service:v1.0 -f Basket.Service\Dockerfile .

docker run -it --rm -p 8000:8080 basket.service:v1.0


## Order 마이크로 서비스

주문 서비스

RabbitMQ 메시지 브로커를이용해 메시지 전달

docker run -d --hostname rabbitmq-host --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management

docker build -t order.service:v1.0 -f Order.Service\Dockerfile .

docker run -it --rm -p 8001:8080 order.service:v1.0
